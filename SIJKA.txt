// * –°–∏–π–∫–∞ v6.2 (Full Control)
// * Copyright (C) 2026 GattaNegra gattanegrabg@gmail.com
// * * This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License.

#include <WiFi.h>
#include <WebServer.h>
#include <SPI.h>
#include <SD.h>
#include <driver/i2s.h>
#include <Wire.h>
#include "RTClib.h"

#define I2S_WS 25
#define I2S_SD 33
#define I2S_SCK 32
#define SD_CS 5
#define SD_MOSI 23
#define SD_MISO 19
#define SD_SCK 18
#define I2C_SDA 21
#define I2C_SCL 22
#define BTN_PIN 0 

const char* ssid = "SSID";
const char* pass = "PASS";

RTC_DS3231 rtc;
WebServer server(80);

int threshold = 800;
int silenceGap = 5;
int maxLenMin = 10;
uint32_t currentSampleRate = 16000;
bool isPaused = false;
bool wifiOn = true;

#define BUFFER_SIZE 1024

void setupI2S(uint32_t rate) {
  i2s_driver_uninstall(I2S_NUM_0);
  i2s_config_t cfg = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
    .sample_rate = rate,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
    .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
    .communication_format = I2S_COMM_FORMAT_STAND_I2S,
    .dma_buf_count = 8,
    .dma_buf_len = 512,
    .use_apll = true 
  };
  i2s_driver_install(I2S_NUM_0, &cfg, 0, NULL);
  i2s_pin_config_t pins = {.bck_io_num=I2S_SCK, .ws_io_num=I2S_WS, .data_out_num=-1, .data_in_num=I2S_SD};
  i2s_set_pin(I2S_NUM_0, &pins);
}

void writeHeader(File f, uint32_t dSize, uint32_t rate) {
  f.seek(0);
  uint32_t fSize = dSize + 36;
  uint32_t br = rate * 2;
  byte h[44] = {'R','I','F','F',0,0,0,0,'W','A','V','E','f','m','t',' ',16,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,2,0,16,0,'d','a','t','a',0,0,0,0};
  memcpy(&h[4], &fSize, 4); memcpy(&h[24], &rate, 4); memcpy(&h[28], &br, 4); memcpy(&h[40], &dSize, 4);
  f.write(h, 44);
}

void handleRoot() {
  if (server.hasArg("th")) threshold = server.arg("th").toInt();
  if (server.hasArg("gap")) silenceGap = server.arg("gap").toInt();
  if (server.hasArg("len")) maxLenMin = server.arg("len").toInt();
  if (server.hasArg("rate")) {
    uint32_t newRate = server.arg("rate").toInt();
    if (newRate != currentSampleRate) {
      currentSampleRate = newRate;
      setupI2S(currentSampleRate);
    }
  }

  String h = "<html><head><meta name='viewport' content='width=device-width, initial-scale=1'><meta charset='UTF-8'></head>";
  h += "<body style='font-family:sans-serif; padding:15px; background:#fafafa;'>";
  h += "<h2>–°–∏–π–∫–∞ v6.2 (Full Control)</h2>";
  h += "<div style='padding:10px; background:#fff; border-radius:5px; border:1px solid #ddd; margin-bottom:10px;'>";
  h += "–°—Ç–∞—Ç—É—Å: " + String(isPaused ? "<b style='color:red;'>–°–ü–†–Ø–ù–ê</b>" : "<b style='color:green;'>–°–õ–£–®–ê</b>") + "<br><br>";
  h += "<a href='/toggle'><button style='padding:10px;'>–ü–£–°–ù–ò/–°–ü–†–ò</button></a> ";
  h += "<a href='/'><button style='padding:10px;'>–û–ü–†–ï–°–ù–ò</button></a><hr>";
  
  h += "<form style='line-height:2.0;'>";
  h += "–ö–∞—á–µ—Å—Ç–≤–æ: <select name='rate'>";
  h += "<option value='16000' "+String(currentSampleRate==16000?"selected":"")+">16kHz</option>";
  h += "<option value='22050' "+String(currentSampleRate==22050?"selected":"")+">22kHz</option>";
  h += "<option value='44100' "+String(currentSampleRate==44100?"selected":"")+">44.1kHz</option></select><br>";
  h += "–ü—Ä–∞–≥ —à—É–º: <input name='th' value='"+String(threshold)+"' size='4'><br>";
  h += "–¢–∏—à–∏–Ω–∞ (—Å–µ–∫): <input name='gap' value='"+String(silenceGap)+"' size='2'><br>";
  h += "–ú–∞–∫—Å. –¥—ä–ª–∂ (–º–∏–Ω): <input name='len' value='"+String(maxLenMin)+"' size='2'><br>";
  h += "<input type='submit' style='margin-top:10px; padding:5px 20px;' value='–ó–ê–ü–ê–ó–ò'></form></div>";
  
  File root = SD.open("/");
  File f = root.openNextFile();
  while(f){
    String n = String(f.name());
    if(n.endsWith(".wav")){
      if(n.startsWith("/")) n.remove(0,1);
      h += "<div>üíæ <a href='/dl?f="+n+"'><b>"+n+"</b></a> ("+String(f.size()/1024)+"KB) | <a href='/del?f="+n+"' style='color:red;'>[X]</a></div><br>";
    }
    f = root.openNextFile();
  }
  h += "</body></html>";
  server.send(200, "text/html", h);
}

void setup() {
  Serial.begin(115200);
  pinMode(BTN_PIN, INPUT_PULLUP);
  WiFi.begin(ssid, pass);
  while (WiFi.status() != WL_CONNECTED) { delay(500); }
  Wire.begin(I2C_SDA, I2C_SCL);
  rtc.begin();
  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  SD.begin(SD_CS);
  setupI2S(currentSampleRate);

  server.on("/", handleRoot);
  server.on("/toggle", [](){ isPaused = !isPaused; server.sendHeader("Location", "/"); server.send(303); });
  server.on("/dl", [](){
    String n = server.arg("f");
    File f = SD.open("/" + n, "r");
    server.sendHeader("Content-Disposition", "attachment; filename=\"" + n + "\"");
    server.streamFile(f, "audio/wav");
    f.close();
  });
  server.on("/del", [](){ SD.remove("/"+server.arg("f")); server.sendHeader("Location", "/"); server.send(303); });
  server.begin();
}

void loop() {
  /* if (digitalRead(BTN_PIN) == LOW) {
    delay(500);
    if (wifiOn) { WiFi.disconnect(); WiFi.mode(WIFI_OFF); wifiOn = false; }
    else { WiFi.begin(ssid, pass); wifiOn = true; }
    while(digitalRead(BTN_PIN) == LOW);
  }
  */

  if (wifiOn) server.handleClient();
  if (isPaused) { delay(10); return; }

  int16_t sBuf[BUFFER_SIZE];
  size_t r;
  i2s_read(I2S_NUM_0, &sBuf, sizeof(sBuf), &r, 10);
  int peak = 0;
  for (int i=0; i<r/2; i++) if(abs(sBuf[i]) > peak) peak = abs(sBuf[i]);

  if (peak > threshold) {
    DateTime now = rtc.now();
    char fn[32]; sprintf(fn, "/%02d-%02d_%02d-%02d-%02d.wav", now.day(), now.month(), now.hour(), now.minute(), now.second());
    File file = SD.open(fn, FILE_WRITE);
    if(file){
      file.write((const byte*)sBuf, 44);
      uint32_t total = 0;
      int sil = 0;
      int webCounter = 0;
      while(total < (uint32_t)maxLenMin * 60 * currentSampleRate * 2){
        if(wifiOn && ++webCounter > 25) { server.handleClient(); webCounter = 0; }
        i2s_read(I2S_NUM_0, &sBuf, sizeof(sBuf), &r, portMAX_DELAY);
        file.write((const byte*)sBuf, r);
        total += r;
        int p = 0;
        for(int i=0; i<r/2; i++) if(abs(sBuf[i]) > p) p = abs(sBuf[i]);
        if(p < (threshold * 0.75)) sil++; else sil = 0;
        if(sil > (silenceGap * (currentSampleRate / (BUFFER_SIZE/2))) || isPaused) break;
      }
      writeHeader(file, total, currentSampleRate);
      file.close();
    }
  }
}
